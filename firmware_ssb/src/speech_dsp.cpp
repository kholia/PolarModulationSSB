#include "speech_dsp.h"
#include <math.h>

#ifdef PICO_BOARD
#include "pico.h"
#else
#define __not_in_flash_func(x) x
#endif

// Runtime-tunable parameters (set via CAT commands *ANNN*, *GNNN*, *CNNN*, *ENNN*)
float sdsp_agc_target = 0.35f;
float sdsp_agc_max_gain = 3.0f;
float sdsp_clip_level = 0.4f;
float sdsp_preemph = 0.7f;

#ifndef SAMPLE_RATE
#define SAMPLE_RATE 32000
#endif

// ── Biquad filter (same structure as polar_mod.cpp) ──────────────────────────
static inline float biquad(float x, float b0, float b1, float b2,
                           float a1, float a2, float *d) {
  float y = b0 * x + d[0];
  d[0] = b1 * x - a1 * y + d[1];
  d[1] = b2 * x - a2 * y;
  return y;
}

// ── Filter coefficients (selected by sample rate) ────────────────────────────
#if SAMPLE_RATE == 32000
// Highpass 300 Hz @ 32 kHz (2nd-order Butterworth)
#define HP_B0 0.9592f
#define HP_B1 -1.9183f
#define HP_B2 0.9592f
#define HP_A1 -1.9166f
#define HP_A2 0.9201f
// Lowpass 2700 Hz @ 32 kHz (2nd-order Butterworth)
#define LP_B0 0.0506f
#define LP_B1 0.1012f
#define LP_B2 0.0506f
#define LP_A1 -1.2711f
#define LP_A2 0.4733f
// DC blocker: ~2000 samples for ~62.5ms time constant
#define DC_ALPHA 0.9995f
#define DC_BETA 0.0005f
// AGC: double sample counts for same time constants at 2x rate
#define AGC_ATTACK 0.97f     // ~5ms at 32kHz (160 samples)
#define AGC_RELEASE 0.9999f  // ~300ms at 32kHz (9600 samples)
#define AGC_ATK_C 0.03f
#define AGC_REL_C 0.0001f
#else
// Highpass 300 Hz @ 16 kHz (2nd-order Butterworth)
#define HP_B0 0.9186f
#define HP_B1 -1.8372f
#define HP_B2 0.9186f
#define HP_A1 -1.8347f
#define HP_A2 0.8408f
// Lowpass 2700 Hz @ 16 kHz (2nd-order Butterworth)
#define LP_B0 0.1568f
#define LP_B1 0.3136f
#define LP_B2 0.1568f
#define LP_A1 -0.6102f
#define LP_A2 0.2374f
// DC blocker: ~1000 samples for ~62.5ms time constant
#define DC_ALPHA 0.999f
#define DC_BETA 0.001f
// AGC time constants at 16kHz
#define AGC_ATTACK 0.94f
#define AGC_RELEASE 0.9998f
#define AGC_ATK_C 0.06f
#define AGC_REL_C 0.0002f
#endif

// ── Filter delay lines ───────────────────────────────────────────────────────
// Pre-clip bandpass 300–2700 Hz (2nd order)
static float pre_hp_d[2] = { 0 };
static float pre_lp_d[2] = { 0 };

// Post-clip bandpass 300–2700 Hz (2nd order)
// NOTE: Kept at 2nd order (not 4th) to minimize group delay and ringing.
// Combined with the pre-clip filter, total is 4th order — enough to reject
// clipping harmonics without smearing speech transients.
static float post_hp_d[2] = { 0 };
static float post_lp_d[2] = { 0 };

// ── Processing state ─────────────────────────────────────────────────────────
static float dc_z = 0;          // DC blocker state
static float emph_prev = 0;     // Pre-emphasis previous sample
static float agc_env = 0;       // AGC envelope follower
static float agc_gain = 1.0f;   // AGC current gain (smoothed)
static int fadein_counter = 0;  // Startup fade-in counter

// 10ms fade-in ramp to suppress filter startup transient ("pop")
#define FADEIN_SAMPLES ((int)(SAMPLE_RATE / 100))  // 160 @ 16kHz, 320 @ 32kHz

void speech_dsp_reset(void) {
  pre_hp_d[0] = pre_hp_d[1] = 0;
  pre_lp_d[0] = pre_lp_d[1] = 0;
  post_hp_d[0] = post_hp_d[1] = 0;
  post_lp_d[0] = post_lp_d[1] = 0;
  dc_z = 0;
  emph_prev = 0;
  agc_env = 0;
  agc_gain = 1.0f;
  fadein_counter = 0;
}

void speech_dsp_retrigger_fadein(void) {
  fadein_counter = 0;
}

// ── Main speech processing pipeline ──────────────────────────────────────────
//
// Pipeline (clip → filter → re-clip):
//   1. DC blocker              – remove DC offset from ADC or WAV data
//   2. Pre-emphasis (0.7)      – aggressive consonant boost (+6dB/oct above ~1kHz)
//   3. Pre-clip bandpass       – 300–2700 Hz (2nd order)
//   4. AGC (smoothed, tgt 0.35) – signal just touches clip → gentle ~1dB clipping
//   5. Hard clipper             – clip at ±0.4 for ~6dB talk power boost
//   6. Post-clip bandpass      – 300–2700 Hz (2nd order, -12dB/oct)
//   7. Re-clip                  – catch peaks regenerated by filter ringing
//   8. Output scaling          – normalize to ±1.0 range
//
// Total filter order: 4th (2nd pre + 2nd post). Low group delay, minimal
// ringing. Previous 8th-order pipeline caused slurriness from excessive
// phase dispersion (~8ms group delay at 300Hz).
//
float __not_in_flash_func(speech_process)(float x) {

  // ── 1. DC blocker (HPF at ~2.5 Hz) ──────────────────────────────────────
  float dc_out = x - dc_z;
  dc_z = dc_z * DC_ALPHA + x * DC_BETA;

  // ── 2. Pre-emphasis: ~+6dB/octave above ~1 kHz ──────────────────────────
  // Aggressive boost ensures consonant energy survives hard clipping
  float emph = dc_out + sdsp_preemph * (dc_out - emph_prev);
  emph_prev = dc_out;

  // ── 3. Pre-clip bandpass 300–2700 Hz ─────────────────────────────────────
  float s1 = biquad(emph, HP_B0, HP_B1, HP_B2, HP_A1, HP_A2, pre_hp_d);
  float s2 = biquad(s1, LP_B0, LP_B1, LP_B2, LP_A1, LP_A2, pre_lp_d);

  // ── 4. AGC: normalize level before clipper (smoothed gain) ───────────────
  float abs_s = fabsf(s2);
  if (abs_s > agc_env)
    agc_env = agc_env * AGC_ATTACK + abs_s * AGC_ATK_C;
  else
    agc_env = agc_env * AGC_RELEASE + abs_s * AGC_REL_C;

  // Target vs clip threshold → signal just touches clip.
  // Gentle ~1dB clipping preserves natural dynamics while still boosting
  // average power. Parameters tunable via CAT commands *ANNN* and *GNNN*.
  float target_gain = agc_gain;  // Hold previous if env too low
  if (agc_env > 0.005f)
    target_gain = sdsp_agc_target / agc_env;
  if (target_gain > sdsp_agc_max_gain) target_gain = sdsp_agc_max_gain;
  if (target_gain < 0.1f) target_gain = 0.1f;         // Min -20dB
  agc_gain = agc_gain * 0.95f + target_gain * 0.05f;  // One-pole smoother

  float agc_out = s2 * agc_gain;

  // ── 5. Hard clipper ──────────────────────────────────────────────────────
  const float clip_level = sdsp_clip_level;
  float clipped = agc_out;
  if (clipped > clip_level) clipped = clip_level;
  if (clipped < -clip_level) clipped = -clip_level;

  // ── 6. Post-clip bandpass 300–2700 Hz (2nd order) ────────────────────────
  // Removes clipping harmonics. 2nd order gives -12dB/oct — enough when
  // combined with pre-clip filter (total 4th order), and avoids the ringing
  // and group delay problems of higher-order cascades.
  float p1 = biquad(clipped, HP_B0, HP_B1, HP_B2, HP_A1, HP_A2, post_hp_d);
  float p2 = biquad(p1, LP_B0, LP_B1, LP_B2, LP_A1, LP_A2, post_lp_d);

  // ── 7. Re-clip (catches peaks from filter ringing) ───────────────────────
  // Post-clip filter ringing can regenerate small peaks above clip level.
  // Re-clipping is cheap and recovers that headroom. No filter needed after
  // this — the re-clip barely produces harmonics since overshoot is tiny.
  if (p2 > clip_level) p2 = clip_level;
  if (p2 < -clip_level) p2 = -clip_level;

  // ── 8. Output scaling ───────────────────────────────────────────────────
  float out = p2 * (1.0f / clip_level);

  // ── Startup fade-in: suppress filter transient pop ─────────────────────
  if (fadein_counter < FADEIN_SAMPLES) {
    out *= (float)fadein_counter / (float)FADEIN_SAMPLES;
    fadein_counter++;
  }

  return out;
}
